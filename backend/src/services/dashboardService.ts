import { GetDashboardResponse } from "../types/response/dashboard/getDashboardResponse";
import DashboardRepository from "../repository/dashboardRepository";
import { GetDashboardSalesGeneratedResponse } from "../types/response/dashboard/getDashboardTotalSalesGeneratedResponse";
import { ShopifyService } from "./shopifyService";
import { ShopifyRepository } from "../repository/shopifyRepository";
import {
  DiscountCodes,
  ShopifyOrderResponse,
} from "../types/response/dashboard/shopifyOrderResponse";
import GetDashboardSalesDTO from "../dto/dashboard/getDashboardSalesDto";

export default class DashboardService {
  private _dashboardRepository: DashboardRepository;
  private _shopifyService: ShopifyService;
  constructor() {
    this._dashboardRepository = new DashboardRepository();
    this._shopifyService = new ShopifyService(new ShopifyRepository());
  }

  public async getDashboard(userId: number): Promise<GetDashboardResponse> {
    const dashboardResponse = await this._dashboardRepository.getDashboard(
      userId
    );
    if (dashboardResponse) {
      return {
        loyaltyMember: dashboardResponse.loyaltyMember
          ? dashboardResponse.loyaltyMember
          : 0,
        RedemptionRate:
          dashboardResponse.loyaltyMember / dashboardResponse.pointEarned,
        pointEarned: dashboardResponse.pointEarned
          ? dashboardResponse.pointEarned
          : 0,
        widgetOpen: 0,
      } as unknown as GetDashboardResponse;
    }
    return dashboardResponse ? dashboardResponse : ({} as GetDashboardResponse);
  }

  public async getDashboardSalesGenerated(
    getDashboardSalesDto: GetDashboardSalesDTO
  ): Promise<GetDashboardSalesGeneratedResponse> {
    const serviceName = `${getDashboardSalesDto.storeName}:shopify`;
    const accessToken = await this._shopifyService.getAccessToken(serviceName);
    const orders = await this._dashboardRepository.getAllOrders(
      accessToken,
      getDashboardSalesDto.storeName
    );
    const totalSales = orders.reduce(
      (total: number, order: ShopifyOrderResponse) => {
        return total + parseFloat(order.total_price);
      },
      0
    );

    const retentionRevenue = this._getRetentionRevenue(
      orders,
      getDashboardSalesDto
    );
    const incentivizedRevenue = this._getIncentivizedRevenue(
      orders,
      getDashboardSalesDto.discountCode
    );
    const conversionRevenue = this._getConversionRevenue(
      orders,
      getDashboardSalesDto.interactionTimeFrame
    );
    const referralRevenue = this._getReferralRevenue(
      orders,
      getDashboardSalesDto.referralSource
    );
    console.log("Total Sales:", totalSales);
    return {
      total: totalSales,
      retentionRevenue: retentionRevenue,
      incentivizedRevenue: incentivizedRevenue,
      conversionRevenue: conversionRevenue,
      referralRevenue: referralRevenue,
    };
  }

  public async getOrders(
    shopName: string
  ): Promise<Array<ShopifyOrderResponse>> {
    const serviceName = `${shopName}:shopify`;
    const accessToken = await this._shopifyService.getAccessToken(serviceName);
    return await this._dashboardRepository.getAllOrders(accessToken, shopName);
  }

  private _getRetentionRevenue(
    orders: Array<ShopifyOrderResponse>,
    getDashboardSalesDto: GetDashboardSalesDTO
  ): number {
    // Filter orders by UTM parameters and tracking timeframe
    const utmCampaign = getDashboardSalesDto.utmCampaign;
    const utmMedium = getDashboardSalesDto.utmMedium;
    const utmSource = getDashboardSalesDto.utmSource;
    const trackingTimeframe = getDashboardSalesDto.trackingTimeFrame; // in days
    const retentionOrders = orders.filter((order: ShopifyOrderResponse) => {
      return (
        order.note_attributes &&
        order.note_attributes.some((attribute: any) => {
          const attributeUTM = attribute.value.toLowerCase();
          return (
            attribute.name.toLowerCase() === "utm" &&
            attributeUTM.includes(`utm_campaign=${utmCampaign}`) &&
            attributeUTM.includes(`utm_medium=${utmMedium}`) &&
            attributeUTM.includes(`utm_source=${utmSource}`)
          );
        })
      );
    });
    // Calculate retention revenue within the specified timeframe
    const currentDate = new Date();
    currentDate.setDate(currentDate.getDate() - trackingTimeframe);
    const retentionRevenue = retentionOrders.reduce(
      (totalRevenue: number, order: ShopifyOrderResponse) => {
        const orderDate = new Date(order.created_at);
        if (orderDate >= currentDate) {
          return totalRevenue + parseFloat(order.total_price);
        }
        return totalRevenue;
      },
      0
    );
    return retentionRevenue;
  }

  private _getIncentivizedRevenue(
    orders: Array<ShopifyOrderResponse>,
    discountCode: string
  ): number {
    // Filter orders by discount code generated by your app
    const incentivizedOrders = orders.filter((order: ShopifyOrderResponse) => {
      return (
        order.discount_codes &&
        order.discount_codes.some(
          (code: DiscountCodes) => code.code === discountCode
        )
      );
    });
    // Calculate incentivized revenue
    const incentivizedRevenue = incentivizedOrders.reduce(
      (totalRevenue: number, order: ShopifyOrderResponse) => {
        return totalRevenue + parseFloat(order.total_price);
      },
      0
    );
    return incentivizedRevenue;
  }

  private _getConversionRevenue(
    orders: Array<ShopifyOrderResponse>,
    interactionTimeframe: number
  ): number {
    // Filter orders by widget interaction within the specified timeframe
    const widgetInteractionOrders = orders.filter(
      (order: ShopifyOrderResponse) => {
        const orderDate = new Date(order.created_at);
        const currentDate = new Date();
        const interactionDate = new Date(
          currentDate.setDate(currentDate.getDate() - interactionTimeframe)
        );
        return orderDate >= interactionDate;
      }
    );

    // Calculate conversion revenue
    const conversionRevenue = widgetInteractionOrders.reduce(
      (totalRevenue: number, order: ShopifyOrderResponse) => {
        return totalRevenue + parseFloat(order.total_price);
      },
      0
    );
    return conversionRevenue;
  }

  private _getReferralRevenue(
    orders: Array<ShopifyOrderResponse>,
    referralSource: string
  ): number {
    // Filter orders by referral source
    const referralOrders = orders.filter((order: ShopifyOrderResponse) => {
      return (
        order.source_name &&
        order.source_name.toLowerCase() === referralSource.toLowerCase()
      );
    });

    // Calculate referral revenue
    const referralRevenue = referralOrders.reduce(
      (totalRevenue: number, order: ShopifyOrderResponse) => {
        return totalRevenue + parseFloat(order.total_price);
      },
      0
    );
    return referralRevenue;
  }
}
